//pi 값은 얼마?
//- 해당 문제는 난수를 이용하여 함수의 값을 확률적으로 계산하는 알고리즘으로 무리수의 근사값을 찾는데 유용하다. 
//  이를 몬테카를로 방법(Monte-Carlo) 방법이라고 한다. 반복문을 활용을 for문을 통해 작성하였고 난수의 생성을 random 함수를 통해 구현해보았다.
//  주어진 구역 내에 n개의 난수를 생성하여 좌표를 n개 생성한다. pi의 추정치는 (해당 함수를 만족하는 좌표의 개수 / 전체 좌표의 수)로 구한다.
//  n의 값이 커질수록 추정치는 해당 무리수의 이론적 값에 근사한다. 출력은 반복 횟수에 따른 pi의 근사값을 출력한다. 
//
//문제 해결 원리
//1. 변수
//	- const int REPEAT : 반복횟수를 지정해주었다. 이 값이 n(n의 최대값으로 생각)이 해당한다. const를 선언해주면서 상수화(변하지 않는 값) 시켜주었다. 
//	- double x,y : 좌표값을 담을 변수다. 0에서 1사이의 값을 저장해주기 위해 double로 선언하였다..
//	- int cnt : 주어진 구역 내에 n개의 난수를 생성하였을 때 주어진 구역 내에 있는 값일 경우 값을 증가시킨 후 저장할 변수이다.
//	- int total : for문 내에서 생성된 전체 좌표의 수를 체크해준다.(전체 반복 횟수 == repeat, for문 반복 중의 전체 반복 횟수 == total)
//	- double estimate : 추정치를 계산한 값을 담을 변수다. x와 y값이 double이고 pi의 값이 3.14...이기에 double로 선언하였다.
//
// 2. random
//	- c의 cstdlib와 ctime 라이브러리를 사용하였다. 
//  - rand() % (1000 + 1) / 1000.0 부분은 0부터 1000까지 난수를 생성하고 1000으로 나누어 0과 1사이의 값을 구한다. 그리고 구한 값을 x, y에 대입하여 좌표값을 만들어준다.
//
// 3. for 문을 이용한 반복
//	(1) 0부터 REPEAT-1까지 반복해준다. (결론적으로 REPEAT번 반복)
//	(2) x와 y에 0에서 1 사이의 랜덤한 난수를 생성하여 대입해준다.
//	(3) 만약 거리 공식을 이용한 값이 1보다 작거나 같다면 해당 값의 범위를 만족하는 좌표이기에 cnt 값을 증가시켜준다.
//	(4) 
//		- 추정치를 계산하여 estimate에 값을 대입해준다. 이떄 cnt의 값을 int에서 double로 명시적 형변환을 해준다.
//		- cnt값을 for 문의 현재를 기준으로 전체 좌표의 수인 total로 나눠준다. 해당 부분은 1/4에 해당하는 부분이기에 *4를 통해서 원래의 값으로 돌려준다.
//	(5) 반복 횟수와 pi의 추정치를 출력해준다.


#include<iostream>
#include<cstdlib>
#include<ctime>
#include<iomanip>
using namespace std;

int main() {
	srand((unsigned int)time(NULL));	//현재값을 시드 값으로 설정
	const int REPEAT = 10000;	// 주어진 구역 내에 n개의 난수를 생성하였을 때 주어진 구역 내에 있는 값일 경우 값을 증가시킨 후 저장할 변수
	double x = 0.0, y = 0.0;	// 전체 좌표의 수(현재까지 생성된 좌표의 수)

	int cnt = 0;	// 주어진 구역 내에 n개의 난수를 생성하였을 때 주어진 구역 내에 있는 값일 경우 값을 증가시킨 후 저장할 변수
	int total = 0;

	double estimate = 0.0;

	for (int i = 0; i < REPEAT; i++) {

		total++;		// 현재까지 생성된 좌표의 수 x,y가 새로 생성될 떄 +1 증가 해줌.
		x = rand() % (1000 + 1) / 1000.0;	// radom한 값을 대입
		y = rand() % (1000 + 1) / 1000.0;

		if (sqrt(pow(x, 2) + pow(y, 2)) <1) {	// 거리 공식을 이용하여 주어진 그림의 크기가 1이기에 1과 같거나 작은 경우 원의 구역 내에 있다
			cnt++;
		}

		estimate = static_cast<double>(cnt) / total * 4;		// 추정치 = 해당 함수를 만족하는 좌표의 개수(cnt) / 전체 좌표의 수(total) 이지만 해당 부분은
																// 1/4에 해당하는 부분이기에 전체를 구하기 위해서 4를 곱해준다.
		cout << "반복 횟수 : " << i + 1 << "	추정치 : " << estimate << endl;
	
	}

	return 0;
}
